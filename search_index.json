[["index.html", "Portfolio 1 Curriculum Vitae", " Portfolio Voornaam achternaam 2025-08-17 1 Curriculum Vitae Contact Informatie voornaam.achternaam@gmail.com github.com/justus789 +1 000-000-0000 Skills Rijbewijs, Sinds 2023 Laboratoriumervaring, Ervaring met biomoleculair onderzoek, waaronder DNA-modificatie en onderzoek naar genexpressie in cellijnen m.b.v. qPCR en Western blot. Ervaring opgedaan met celkweek, pipetteren en steriele werktechnieken. Statistische analyse Toepassen van statistische toetsmethoden met Excel en Jasp Data Science, Ervaring met R, bash en SQL, met een focus op op analyseren van DNA en gen relateerde datasets. Stage plek gezocht Op zoek naar een stage plek die werkervaring aanbied in het gebied van medicijnontwikkeling. Specifiek gericht op antilichaamontwikkeling. Ik ben erg geïnteresseerd in het immuunsysteem van de mens en antilichamen zijn een groot onderdeel van de gezondheid. Daarom is dit voor mij een perfecte kans om anderen te helpen. Educatie Life Sciences, 2022 - Nu, Hogeschool Utrecht Biologie en medisch laboratorium onderzoek aan Hogeschool Utrecht. vwo-atheneum N/G, 2015-2022, Frits Philips lyceum-mavo Middelbare school Werkervaring Crewtrainer - McDonalds, 2024-2025, Meerdere cursussen gevolgd aan de Hamburger University. Zoals leadership skills en doceren. Crewmember - McDonalds, 2022-2024, Crewmember bij de McDonalds voor 2 jaar Verkoopmedewerker - JUMBO supermarkt, 2021 - 2022, Voor 1 jaar als vakkenvuller gewerkt "],["plan-voor-de-toekomst.html", "2 Plan voor de toekomst", " 2 Plan voor de toekomst Ik wil in een lab werken waar ik kan werken aan ‘de toekomst’. Ergens waar ik echt iets kan doen wat later mensen helpt. Dit kan zijn in de ontwikkeling van medicatie maar ook in het onderzoeken van ziektes. Ik ben nog niet helemaal klaar om te starten in deze richting. Ik heb al op het lab gewerkt wat een benodigde skill is. Beter worden in het analyseren van de data wil ik ontwikkelen als skill. Tijdens de profilering van Data Science for biology 1 hebben we geleerd data te analyseren, dit met R en bash, ook is Jasp en Excel gebruikt bij de Data Science cursus. Tijdens Data Science for biology 2 wil ik meer leren over het ontwikkelen van antilichamen. Hier komt tegenwoordig een heleboel machine learning bij te pas. Daarom wil ik proberen of ik een package met machine learning kan leren. "],["vrije-ruimte.html", "3 Vrije ruimte", " 3 Vrije ruimte Nieuwe skill Ik ben op zoek naar een stage in de richting van medicijnontwikkeling, daarom probeer ik de skill die ik ga leren hierop aan te passen. Na onderzoek is gebleken dat er veel gebruik wordt gemaakt van machine learning voor het maken van antilichamen. Hierom wil ik in de vrije ruimte een package leren die wordt gebruikt voor antilichaamontwikkeling. Ik ben van plan deze skill te leren door uit te zoeken welke package het meest gebruikt wordt voor antilichaamontwikkeling. De package ga ik helemaal doornemen, dit houdt in alle opties lezen en leren wat deze opties betekenen of in welke situatie welke optie nodig is. Deze package ga ik uittesten op proefdata die ik online ga zoeken. Het resultaat van deze test zal bewijzen of ik de package goed kan gebruiken. Ik probeer binnen 4 uur een package te vinden die ik ga gebruiken. Hier valt ook het downloaden van de package onder. Ik wil 8 uur spenderen aan het leren van de package, het doornemen van de verscheidene opties. 18 uur probeer ik de package uit op proefdata. Hier zal ik ook de verschillende opties binnen de package uitproberen om te kijken wat er veranderd. De laatste 2 uur wordt gebruikt om de resultaten vast te leggen en een conclusie te maken. Ik heb packages gezocht om mee te werken. Eerst kwam ik epitopepredict tegen, maar dit bleek een Python package te zijn. Hierom koos ik voor immunarch, deze kwam ik iets later tegen. De werking is net anders, epitopepredict kan een voorspelling geven over MHC1 en MHC2 epitopen. Immunarch analyseert data en voorspelt de TCR en BCR van de imuuncellen. Aangezien immunarch wel een R package is heb ik hiervoor gekozen. In de eerste paar code chunk wordt de ‘lightning-fast start’ uitgeprobeerd. Ook om te kijken wat voor data analyse eruit komt. Eerst package installeren install.packages(&quot;immunarch&quot;) # Install the package ## package &#39;immunarch&#39; successfully unpacked and MD5 sums checked ## ## The downloaded binary packages are in ## C:\\Users\\justu\\AppData\\Local\\Temp\\RtmpIpRd8h\\downloaded_packages Package activeren, daarnaast ook de test dataset activeren. library(immunarch); data(immdata) # Load the package and the test dataset Vanaf hier is te zien dat alle grafieken worden gegenereerd met vis(). Deze functie kan alle data die door Immunarch wordt gebruikt herkennen en zelf daarop de grafiek aanpassen. De functie repOverlap laat de overlap zien tussen repertoires. De imuun receptor sequenties die overeenkomen tussen repertoires. In deze grafiek is te zien dat A2-i132 en A2-i133 erg veel overlap hebben. repOverlap(immdata$data) %&gt;% vis() # Compute and visualise the most important statistics: geneUsage() is een functie die berekent hoeveel het immunorecepetor gen wordt gebruikt. In de test data is te zien dat TRBV5-1 erg actief is. geneUsage(immdata$data[[1]]) %&gt;% vis() # public clonotypes, gene usage, sample diversity repDiversity kan de repertoire diversiteit berekenen. Het aantal verschillende soorten of objecten, worden berekent. Hier zijn vele verschillende methoden voor, repDiversity pakt als standaard Chao1 wat het aantal soorten in de populatie voorspelt. repDiversity(immdata$data) %&gt;% vis(.by = &quot;Status&quot;, .meta = immdata$meta) # Group samples Om de functies beter te begrijpen zoek ik de ?help van functies op. De dataset die gebruikt wordt bestaat uit meerdere tibbles, eerst een lijst met genen. Daarna hoe de dataset er per gen uitziet. Als laatste een dataset met de metadata (informatie over waar de data vandaan komt). immdata$data$`A2-i129` ## # A tibble: 6,532 × 15 ## Clones Proportion CDR3.nt CDR3.aa V.name D.name J.name V.end D.start D.end ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 173 0.0204 TGCGCCAGC… CASSQE… TRBV4… TRBD1 TRBJ2… 16 18 26 ## 2 163 0.0192 TGCGCCAGC… CASSYR… TRBV4… TRBD1 TRBJ2… 11 13 18 ## 3 66 0.00776 TGTGCCACC… CATSTN… TRBV15 TRBD1 TRBJ2… 11 16 22 ## 4 54 0.00635 TGTGCCACC… CATSIG… TRBV15 TRBD2 TRBJ2… 11 19 25 ## 5 48 0.00565 TGTGCCAGC… CASSPW… TRBV27 TRBD1 TRBJ1… 11 16 23 ## 6 48 0.00565 TGCGCCAGC… CASQGD… TRBV4… TRBD1 TRBJ1… 8 13 19 ## 7 40 0.00471 TGCGCCAGC… CASSQD… TRBV4… TRBD1 TRBJ2… 16 21 26 ## 8 31 0.00365 TGTGCCAGC… CASSEE… TRBV2 TRBD1 TRBJ1… 15 17 20 ## 9 30 0.00353 TGCGCCAGC… CASSQP… TRBV4… TRBD1 TRBJ2… 14 23 28 ## 10 28 0.00329 TGTGCCAGC… CASSWV… TRBV6… TRBD1 TRBJ2… 12 20 25 ## # ℹ 6,522 more rows ## # ℹ 5 more variables: J.start &lt;int&gt;, VJ.ins &lt;dbl&gt;, VD.ins &lt;dbl&gt;, DJ.ins &lt;dbl&gt;, ## # Sequence &lt;lgl&gt; immdata$meta ## # A tibble: 12 × 6 ## Sample ID Sex Age Status Lane ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A2-i129 C1 M 11 C A ## 2 A2-i131 C2 M 9 C A ## 3 A2-i133 C4 M 16 C A ## 4 A2-i132 C3 F 6 C A ## 5 A4-i191 C8 F 22 C B ## 6 A4-i192 C9 F 24 C B ## 7 MS1 MS1 M 12 MS C ## 8 MS2 MS2 M 30 MS C ## 9 MS3 MS3 M 8 MS C ## 10 MS4 MS4 F 14 MS C ## 11 MS5 MS5 F 15 MS C ## 12 MS6 MS6 F 15 MS C Bij veel voorbeelden die volgen wordt de vis() functie ook erachteraan geplakt. Deze functie maakt het resultaat van de code overzichtelijker. Daarnaast kan met vis() een .by optie gebruikt worden om te groeperen op metadata zoals geslacht. repExplore wordt gebruikt om een eerste indruk te krijgen van de data. De functie kan standaard statistiek berekenen voor een repertoire. De optie .method bepaalt wat berekent wordt voor je repertoire. In het voorbeeld is “volume” gebruikt wat het aantal unieke receptor clonotypes berekent. Andere mogelijkheden zijn: “count” voor de relatieve dichtheid, “len” om sequentie lengte te berekenen. “clones” geeft het aantal clones in het repertoire. repExplore heeft een .col optie om aan te geven of het gaat over nucleotiden (“nt”) of aminozuren (“aa”) repExplore(immdata$data, .method = &quot;volume&quot;) ## Sample Volume ## A2-i129 A2-i129 6443 ## A2-i131 A2-i131 6375 ## A2-i133 A2-i133 6300 ## A2-i132 A2-i132 6721 ## A4-i191 A4-i191 5058 ## A4-i192 A4-i192 5763 ## MS1 MS1 5301 ## MS2 MS2 7043 ## MS3 MS3 6310 ## MS4 MS4 7313 ## MS5 MS5 5588 ## MS6 MS6 7278 repExplore(immdata$data, .method = &quot;count&quot;) %&gt;% vis(.by = c(&quot;Sex&quot;, &quot;Lane&quot;), immdata$meta) fixVis() wordt gebruikt om grafieken publicatie klaar te maken. p2 &lt;- vis(exp_len, .by = &quot;Status&quot;, .meta = immdata$meta) p2 Met repclonality kan de clonale proporties gemeten worden. De .method kan verschillen. In dit voorbeeld wordt “homeo” gebruikt voor de .method, deze meet de relatieve dichtheid als deel van het hele repertoire door clonale groepen. “clonal.prop” meet de clonale proportie, “top” meet de 10 grootste clonotypes en “rare” berekent de de groepen met de laagste of ‘zeldzaamste’ clonotypes. Voor “homeo” kan je .clone.types gebruiken om aan te geven wat de proportie van de dichtheid is. Zonder invoer worden de getallen gekoppeld aan de groottes in de grafiek hieronder. repClonality(immdata$data, .method = &quot;homeo&quot;) %&gt;% vis(.by = &quot;Sex&quot;, immdata$meta) repFilter() werkt als filter(), met deze functie kan je data selecteren die je wilt gebruiken of juist data weglaten. .method heeft de inputs: “by.clonotype” (wat de standaard is), “by.meta” en “by.rep”. In voorbeeld hieronder wordt het mannelijk geslacht eruit gefilterd. exclude kan worden vervangen met ‘morethan’, ‘lessthan’ en ‘interval’ om aan te geven dat je de waardes tussen 2 mogelijkheden wilt gebruiken. filtered &lt;- repFilter(immdata, .method = &quot;by.meta&quot;, .query = list(Sex = exclude(&quot;M&quot;)))$meta filtered ## # A tibble: 6 × 6 ## Sample ID Sex Age Status Lane ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 A2-i132 C3 F 6 C A ## 2 A4-i191 C8 F 22 C B ## 3 A4-i192 C9 F 24 C B ## 4 MS4 MS4 F 14 MS C ## 5 MS5 MS5 F 15 MS C ## 6 MS6 MS6 F 15 MS C Bij repOverlap kan de optie .col gegeven worden. Dit kan erg nuttig zijn als een gen wat voor het epitoop codeert wordt vergeleken. repOverlap gebruikt standaard de aminozuur sequenties als de optie niet wordt aangegeven, hieronder is dit aangepast naar “nt” voor nucleotiden sequenties. repOverlap(immdata$data, .col = &quot;nt&quot;) %&gt;% vis() De .col accepteert V gene segments, J gene segments en D gene segments als invoer. Dit is gedaan in de grafiek hieronder met de V gene segments. Je ziet dat als er specifieker wordt gekeken er andere genen meer kunnen overlappen, hier bijvoorbeeld de genen A2-i129 en A2-i132. repOverlap(immdata$data, .col = &quot;nt+v&quot;) %&gt;% vis() repOverlap kan andere methode gebruiken. Hieronder wordt de “jaccard” methode gebruikt. Deze laat het percentage wat overeenkomt zien ten opzicht van het geheel. In dit geval wordt de grafiek onduidelijk omdat de getallen erg lang zijn, wel is te zien dat met deze methode dezelfde genen overlappen aangezien dezelfde hokjes rood of roder worden. Zie figuur bij chunk repoverlap col repOverlap(immdata$data, .col = &quot;nt&quot;, .method = &quot;jaccard&quot;) %&gt;% vis() ## | | | 0% | |= | 1% | |== | 3% | |=== | 4% | |==== | 5% | |==== | 6% | |===== | 8% | |====== | 9% | |======= | 10% | |======== | 12% | |========= | 13% | |========== | 14% | |=========== | 15% | |============ | 17% | |============= | 18% | |============= | 19% | |============== | 21% | |=============== | 22% | |================ | 23% | |================= | 24% | |================== | 26% | |=================== | 27% | |==================== | 28% | |===================== | 29% | |====================== | 31% | |====================== | 32% | |======================= | 33% | |======================== | 35% | |========================= | 36% | |========================== | 37% | |=========================== | 38% | |============================ | 40% | |============================= | 41% | |============================== | 42% | |=============================== | 44% | |=============================== | 45% | |================================ | 46% | |================================= | 47% | |================================== | 49% | |=================================== | 50% | |==================================== | 51% | |===================================== | 53% | |====================================== | 54% | |======================================= | 55% | |======================================= | 56% | |======================================== | 58% | |========================================= | 59% | |========================================== | 60% | |=========================================== | 62% | |============================================ | 63% | |============================================= | 64% | |============================================== | 65% | |=============================================== | 67% | |================================================ | 68% | |================================================ | 69% | |================================================= | 71% | |================================================== | 72% | |=================================================== | 73% | |==================================================== | 74% | |===================================================== | 76% | |====================================================== | 77% | |======================================================= | 78% | |======================================================== | 79% | |========================================================= | 81% | |========================================================= | 82% | |========================================================== | 83% | |=========================================================== | 85% | |============================================================ | 86% | |============================================================= | 87% | |============================================================== | 88% | |=============================================================== | 90% | |================================================================ | 91% | |================================================================= | 92% | |================================================================== | 94% | |================================================================== | 95% | |=================================================================== | 96% | |==================================================================== | 97% | |===================================================================== | 99% | |======================================================================| 100% Hieronder wordt de methode “cosine” gebruikt. Deze methode meet of er veel overlap zit tussen 2 vectors die de cosinus meten van de hoek die ertussen zit. Op deze manier zijn weer andere genen erg overlappend. Al is deze methode weer niet erg overzichtelijk door getallen met veel decimalen. repOverlap(immdata$data, .col = &quot;nt&quot;, .method = &quot;cosine&quot;) %&gt;% vis() ## | | | 0% | |= | 1% | |== | 3% | |=== | 4% | |==== | 5% | |==== | 6% | |===== | 8% | |====== | 9% | |======= | 10% | |======== | 12% | |========= | 13% | |========== | 14% | |=========== | 15% | |============ | 17% | |============= | 18% | |============= | 19% | |============== | 21% | |=============== | 22% | |================ | 23% | |================= | 24% | |================== | 26% | |=================== | 27% | |==================== | 28% | |===================== | 29% | |====================== | 31% | |====================== | 32% | |======================= | 33% | |======================== | 35% | |========================= | 36% | |========================== | 37% | |=========================== | 38% | |============================ | 40% | |============================= | 41% | |============================== | 42% | |=============================== | 44% | |=============================== | 45% | |================================ | 46% | |================================= | 47% | |================================== | 49% | |=================================== | 50% | |==================================== | 51% | |===================================== | 53% | |====================================== | 54% | |======================================= | 55% | |======================================= | 56% | |======================================== | 58% | |========================================= | 59% | |========================================== | 60% | |=========================================== | 62% | |============================================ | 63% | |============================================= | 64% | |============================================== | 65% | |=============================================== | 67% | |================================================ | 68% | |================================================ | 69% | |================================================= | 71% | |================================================== | 72% | |=================================================== | 73% | |==================================================== | 74% | |===================================================== | 76% | |====================================================== | 77% | |======================================================= | 78% | |======================================================== | 79% | |========================================================= | 81% | |========================================================= | 82% | |========================================================== | 83% | |=========================================================== | 85% | |============================================================ | 86% | |============================================================= | 87% | |============================================================== | 88% | |=============================================================== | 90% | |================================================================ | 91% | |================================================================= | 92% | |================================================================== | 94% | |================================================================== | 95% | |=================================================================== | 96% | |==================================================================== | 97% | |===================================================================== | 99% | |======================================================================| 100% Voor geneUsage kan je per gensoort kijken naar de usage, zolang er een ‘species’ bij gegeven wordt. als voorbeeld: gene = “HomoSapiens.TRBJ”. Hieronder wordt dit voorbeeld uitgevoerd, je ziet het gebruik van alle TRBJ gen soorten. geneUsage(immdata$data[[1]], .gene = &quot;HomoSapiens.TRBJ&quot;) %&gt;% vis() Om meer informatie te krijgen over de soorten genen kan gene_stats() gebruikt worden. gene_stats() laat de alias zien van de ‘species’ naast de kolom met de ‘species’. Dan zie je de kolommen met genes en het aantal dat de ‘species’ ervan hebben. gene_stats() ## alias species ighd ighj ighv igij igkj igkv iglj iglv traj ## 1 bt BosTaurus 21 4 25 0 1 6 5 26 46 ## 2 cd CamelusDromedarius 0 0 0 0 0 0 0 0 0 ## 3 clf CanisLupusFamiliaris 0 0 0 0 0 0 0 0 0 ## 4 dr DanioRerio 7 7 0 3 0 0 0 0 0 ## 5 hs HomoSapiens 30 13 248 0 5 64 7 69 57 ## 6 macmul MacacaMulatta 24 7 19 0 4 83 5 0 0 ## 7 mmc MusMusculusCastaneus 0 0 0 0 0 4 0 0 0 ## 8 mmd MusMusculusDomesticus 0 0 0 0 0 2 0 0 0 ## 9 musmus MusMusculus 32 8 225 0 8 109 3 5 42 ## 10 oa OrnithorhynchusAnatinus 3 10 0 0 0 0 0 0 0 ## 11 oc OryctolagusCuniculus 10 11 39 0 8 26 2 20 0 ## 12 om OncorhynchusMykiss 9 7 6 0 0 0 0 0 0 ## 13 rn RattusNorvegicus 30 4 113 0 6 132 2 8 0 ## 14 smth MusMusculusMolossinus 0 0 0 0 0 1 0 0 0 ## 15 smth MusMusculusMusculus 0 0 0 0 0 1 0 0 0 ## 16 smth MusSpretus 0 0 0 0 0 2 0 2 0 ## 17 ss SusScrofa 5 5 15 0 8 19 4 14 0 ## trav trbd trbj trbv trdd trdj trdv trgj trgv ## 1 0 0 0 0 5 3 0 6 15 ## 2 0 0 0 0 0 0 7 2 2 ## 3 0 2 8 19 0 0 0 7 8 ## 4 0 0 0 0 0 0 0 0 0 ## 5 60 3 14 64 3 4 6 4 10 ## 6 0 2 15 58 0 0 0 0 0 ## 7 0 0 0 0 0 0 0 0 0 ## 8 0 0 0 0 0 0 0 0 0 ## 9 145 2 14 23 2 3 7 0 11 ## 10 0 0 0 0 0 0 0 0 0 ## 11 0 0 0 0 0 0 0 0 0 ## 12 0 1 9 0 0 0 0 0 0 ## 13 0 0 0 0 0 0 0 0 0 ## 14 0 0 0 0 0 0 0 0 0 ## 15 0 0 0 0 0 0 0 0 0 ## 16 0 0 0 0 0 0 0 0 0 ## 17 0 0 0 0 0 0 0 0 0 Nu testen we een voorbeeld uit de gene_stats grafiek. We pakken de RattusNorvegicus met IGHD. geneUsage(immdata$data, .gene = &quot;RattusNorvegicus.IGHD&quot;) %&gt;% vis() geneUsage heeft ook een .ambig optie. Dit is om ‘gene assignments’ te regelen. Deze optie staat standaard op “inc” om alle verschillende gen sequenties mee te nemen. Deze standaard optie wordt eerst getest. Daarna een grafiek waar “exc” is gebruikt. Wat je ziet komt doordat alle genen vallen onder ‘ambiguous’. De dataset kan niet zeker de genen benoemen, bij ‘inc’ neemt geneUsage deze niet zekere genen ook mee. Bij ‘exc’ niet waardoor de genen verdwijnen. geneUsage(immdata$data, .gene = &quot;BosTaurus.IGHV&quot;, .ambig = &quot;inc&quot;) %&gt;% vis() geneUsage(immdata$data, .gene = &quot;BosTaurus.IGHV&quot;, .ambig = &quot;exc&quot;) %&gt;% vis() geneUsage heeft ook een .type optie welke accepteert de waardes: “segment”, “allele” en “family”. Voor segment worden alle segmenten gepakt, bij allele alle allelen en family pakt de groep. Zoals te zien bij geneusage6 verandert TRBV10-1, TRBV10-2 en TRBV10-3 in 1 groep genaamd TRBV10 geneUsage(immdata$data[[1]], .type =&quot;allele&quot;) %&gt;% vis geneUsage(immdata$data[[1]], .type =&quot;family&quot;) %&gt;% vis repDiversity heeft opties die hetzelfde werken als bij eerdere functies, zoals .col waarmee de kolom word aangegeven(“aa” of “nt”). repDiversity heeft ook een .method optie, deze heeft echter andere methodes waarmee gewerkt worden. De methode hier heeft invloed op wat er berekent wordt. In het voorbeeld hieronder is de Inverse Simpson manier gebruikt. Deze methode kan de ongelijkheid berekenen zodat niet één clonotype overheerst. Daarnaast gebruikt deze methode een gemiddelde zodat niet alles even veel meetelt. repDiversity(immdata$data, .method= &quot;inv.simp&quot;) %&gt;% vis(.by = &quot;Status&quot;, .meta = immdata$meta) De methode d50 berekent het minimum aan verschillende clonotypes wat samen 50% van het alle sequenties zijn. Op deze grafiek is goed te zien of er veel of weinig clones bijdragen aan de 50% en dus of repDiversity(immdata$data, .method= &quot;d50&quot;) %&gt;% vis(.by = &quot;Status&quot;, .meta = immdata$meta) trackClonotypes is een functie waarmee clonotypes gemakkelijk kunnen worden geselecteerd. De functie heeft tweede input .which, waarmee aan wordt gegeven hoeveel gekozen moet worden, in het voorbeeld hieronder is de eerste input van de optie .which A2-i129, daarom wordt deze repertoire gebruikt, de tweede input van .which is de 5 wat betekent dat er 5 langste sequenties worden geselecteerd. Hier worden sequenties geselecteerd omdat .col staat op “nt+v” waardoor de nucleotiden sequenties met V gene segments gebruikt worden. tc1 &lt;- trackClonotypes(immdata$data, list(&quot;A2-i129&quot;, 5), .col = &quot;nt+v&quot;) tc1 ## Key: &lt;CDR3.nt, V.name&gt; ## CDR3.nt V.name A2-i129 ## &lt;char&gt; &lt;char&gt; &lt;num&gt; ## 1: TGCGCCAGCAGCCAAGAAGGGACAGGGTATTCCGGGGAGCTGTTTTTT TRBV4-1 0.020352941 ## 2: TGCGCCAGCAGCTACAGGGTTGGCACAGATACGCAGTATTTT TRBV4-1 0.019176471 ## 3: TGTGCCACCAGCACCAACAGGGGCGGAACCCCAGCAGATACGCAGTATTTT TRBV15 0.007764706 ## 4: TGTGCCACCAGCATCGGAGGCGGGAGCTACGAGCAGTACTTC TRBV15 0.006352941 ## 5: TGTGCCAGCAGTCCTTGGACAGGGAGTATGGCCCTCCACTTT TRBV27 0.005647059 ## A2-i131 A2-i133 A2-i132 A4-i191 A4-i192 MS1 MS2 MS3 MS4 MS5 MS6 ## &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1: 0 0 0 0 0 0 0 0 0 0 0 ## 2: 0 0 0 0 0 0 0 0 0 0 0 ## 3: 0 0 0 0 0 0 0 0 0 0 0 ## 4: 0 0 0 0 0 0 0 0 0 0 0 ## 5: 0 0 0 0 0 0 0 0 0 0 0 vis(tc1) Met trackClonotypes kan ook een nucleotide sequentie getracked worden. Dit werkt ook als er meerdere sequenties in een lijst worden gezet. sequence &lt;- &quot;CASSLEETQYF&quot; trackClonotypes(immdata$data, sequence, .col = &quot;aa&quot;) %&gt;% vis() Eerder is al aangegeven dat de vis() functie handig is omdat deze de data van immunarch herkent en zelf bedenkt wat voor grafiek moet worden gemaakt. Toch zijn ook voor vis() bepaalde opties om de grafiek meer naar eigen wens te maken. Deze opties staan niet in ?help maar wel in de tutorial online. .plot kan worden aangepast naar: “smooth”, “area” of “line”. target &lt;- c(&quot;CASSLEETQYF&quot;, &quot;CASSDSSGGANEQFF&quot;, &quot;CASSDSSGSTDTQYF&quot;, &quot;CASSLAGGYNEQFF&quot;, &quot;CASSDSAGGTDTQYF&quot;, &quot;CASSLDSYEQYF&quot;, &quot;CASSSAGGYNEQFF&quot;) tc &lt;- trackClonotypes(immdata$data, target, .col = &quot;aa&quot;) vis(tc, .plot = &quot;smooth&quot;) vis(tc, .plot = &quot;area&quot;) vis(tc, .plot = &quot;line&quot;) vis() heeft een .order optie om de volgorde van gegeven data te veranderen. # Passing indices names(immdata$data)[c(1, 3, 5)] # check sample names ## [1] &quot;A2-i129&quot; &quot;A2-i133&quot; &quot;A4-i191&quot; # You can change the order vis(tc, .order = c(5, 1, 3)) De vis() functie kan gebruik maken van scale_fill_brewer om de kleuren aan te passen. Immunarch kan ook clonotypes identificeren met online databases. De tutorial van immunarch wordt hieronder gevolgd om dit proces te demonstreren. De functies die we in dit gedeelte tegenkomen zullen ook verder onderzocht worden. Na het downloaden van de SearchTable wordt dbLoad() gebruikt. dbLoad() kan VDJDB, McPAS-TCR en TBAdb databases laden. er zijn een paar opties die in de functie zijn verwerkt zodat de functie weet wat voor data er wordt geladen. De eerste input is de path naar de database, hier wordt de VDJDB database gebruikt die al is gefiltert op ‘species’ HomoSapiens. ‘.species’ is hier HomoSapiens. ‘.chain’ specificeert wat voor chains in de database moeten zitten. We kijken naar TRB chains dus dat wordt ingevoerd. Omdat er in de tutorial gekeken wordt naar het Cytomegalovirus wordt dit aangegeven met .pathology = “CMV”. vdjdb_st = dbLoad(&quot;vrije_ruimte/VDJDB_database/SearchTable-2025-05-25 22_39_15.094.tsv&quot;, &quot;vdjdb-search&quot;, .species = &quot;HomoSapiens&quot;, .chain = &quot;TRB&quot;, .pathology = &quot;CMV&quot;) vdjdb_st ## # A tibble: 20,572 × 19 ## complex.id Gene CDR3 V J Species `MHC A` `MHC B` `MHC class` ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 0 TRB CASSLGVDFNY… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 2 0 TRB CSVTGTSYEQYF TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 3 0 TRB CATSSPGLASD… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 4 0 TRB CASSSPLLSSD… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 5 0 TRB CASSLSGGLWS… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 6 0 TRB CSVVGRYYEQYF TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 7 0 TRB CATSGPSASYE… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 8 0 TRB CASSFNGPNTE… TRBV… TRBJ… HomoSa… HLA-B*… B2M MHCI ## 9 0 TRB CAISEFGLAGS… TRBV… TRBJ… HomoSa… HLA-B*… B2M MHCI ## 10 0 TRB CASSLFDGTGS… TRBV… TRBJ… HomoSa… HLA-B*… B2M MHCI ## # ℹ 20,562 more rows ## # ℹ 10 more variables: Epitope &lt;chr&gt;, `Epitope gene` &lt;chr&gt;, ## # `Epitope species` &lt;chr&gt;, Reference &lt;chr&gt;, Method &lt;chr&gt;, Meta &lt;chr&gt;, ## # CDR3fix &lt;chr&gt;, Score &lt;dbl&gt;, Chain &lt;chr&gt;, Pathology &lt;chr&gt; data(immdata) Nu kan met dbAnnotate alle clonotypes worden geannoteert. De CDR3 aminozuur sequenties worden gematched met CDR3 sequenties in de VDJdb database. De 3e input van dbAnnotate is .data.col, deze geeft aan welke kolom van je eigen repertoire wordt gematched. De 4e input is de .db.col om de kolom van de database aan te geven waarmee wordt gematched. dbAnnotate(immdata$data, vdjdb_st, &quot;CDR3.aa&quot;, &quot;CDR3&quot;) ## CDR3.aa Samples A2-i129 A2-i131 A2-i133 A2-i132 A4-i191 A4-i192 ## &lt;char&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1: CASSLEETQYF 11 3 3 4 7 1 2 ## 2: CASSLGETQYF 11 6 4 2 8 4 0 ## 3: CASSFQETQYF 9 3 2 2 4 2 0 ## 4: CASSQETQYF 9 5 2 1 2 3 2 ## 5: CASSSSYEQYF 9 1 0 0 1 2 2 ## --- ## 600: CSVGTGTYEQYF 1 0 0 0 0 1 0 ## 601: CSVQGGAYNEQFF 1 0 1 0 0 0 0 ## 602: CSVQGGSYNEQFF 1 0 1 0 0 0 0 ## 603: CSVVATNEKLFF 1 0 0 1 0 0 0 ## 604: CSVVGTGNTEAFF 1 0 0 0 0 0 0 ## MS1 MS2 MS3 MS4 MS5 MS6 ## &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; &lt;num&gt; ## 1: 1 0 3 1 1 1 ## 2: 1 3 1 2 5 1 ## 3: 1 1 0 4 0 2 ## 4: 0 1 0 0 4 1 ## 5: 1 1 0 1 1 3 ## --- ## 600: 0 0 0 0 0 0 ## 601: 0 0 0 0 0 0 ## 602: 0 0 0 0 0 0 ## 603: 0 0 0 0 0 0 ## 604: 0 0 0 0 1 0 In de tabel die dbAnnotate genereert zijn de sequenties te zien in de eerste kolom. De tweede kolom zijn de ‘Samples’. Dit geeft aan hoe veel clonotypes zijn gevonden, waarna de verschillende clonotypes komen en hoevaak ze voorkomen. Immunarch geeft ook voorbeelden hoe je specifieke epitoop sequenties kan opzoeken. Hiervoor wordt dplyr gebruikt. library(dplyr) table(vdjdb_st$Epitope) ## ## ARNLVPMVATVQGQN AYAQKIFKI CPSQEPMSIYVY CRVLCCYVL CVETMCNEY ## 3 39 5 31 2 ## DEEDAIAAY EDVPSGKLFMHVTLG EFFWDANDIY EHPTFTSQYRIQGKL ELKRKMIYM ## 2 1 1 30 5 ## ELRRKMMYM FPTKDVAL FRCPRRFCF IPSINVHHY KLGGALQAK ## 11 15 10 105 13681 ## LLQTGIHVRVSQPSL LSEFCRVLCCYVLEE MLNIPSINV NEGVKAAW NLVPMVATV ## 305 2 73 299 5067 ## QIKVRVDMV QIKVRVKMV QYDPVAALF RPHERNGFTV RPHERNGFTVL ## 22 36 39 4 79 ## TPRVTGGGAM VLEETSVML VMAPRTLIL VTEHDTLLY YILEETSVM ## 343 20 2 205 2 ## YSEHPTFTSQY ## 133 vdjdb &lt;- vdjdb_st %&gt;% filter(vdjdb_st$Epitope == &quot;NLVPMVATV&quot;) vdjdb ## # A tibble: 5,067 × 19 ## complex.id Gene CDR3 V J Species `MHC A` `MHC B` `MHC class` ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 0 TRB CASSYSTGTPG… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 2 0 TRB CASTPAGGAPG… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 3 0 TRB CASSLAPGATN… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 4 0 TRB CASSFSGGAPG… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 5 0 TRB CASSYFGGNTE… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 6 0 TRB CASSLAPGATS… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 7 0 TRB CASSYQTGTIY… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 8 0 TRB CASSPQTGAIY… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 9 0 TRB CASSALGGGGT… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## 10 0 TRB CASSPVQGAFY… TRBV… TRBJ… HomoSa… HLA-A*… B2M MHCI ## # ℹ 5,057 more rows ## # ℹ 10 more variables: Epitope &lt;chr&gt;, `Epitope gene` &lt;chr&gt;, ## # `Epitope species` &lt;chr&gt;, Reference &lt;chr&gt;, Method &lt;chr&gt;, Meta &lt;chr&gt;, ## # CDR3fix &lt;chr&gt;, Score &lt;dbl&gt;, Chain &lt;chr&gt;, Pathology &lt;chr&gt; De getKmers functie kan Kmers detecteren. Deze berekent hoeveel kmers er aanwezig zijn in een repertoire. Alleen de ‘.k’ optie is nieuw vergeleken met de andere functies. ‘.k’ is een integer die aangeeft hoe lang de kmers moeten zijn. De optie .coding staat standaard op TRUE, deze optie vertelt de functie of niet coderende sequenties moeten worden meegeteld. De standaard filtert alle niet coderende sequenties eruit. kmers &lt;- getKmers(immdata$data[[1]], 3) kmers ## # A tibble: 4,405 × 2 ## Kmer Count ## &lt;chr&gt; &lt;int&gt; ## 1 AAA 6 ## 2 AAD 5 ## 3 AAE 9 ## 4 AAF 2 ## 5 AAG 37 ## 6 AAI 2 ## 7 AAK 5 ## 8 AAL 4 ## 9 AAM 1 ## 10 AAN 13 ## # ℹ 4,395 more rows Kmers kan ook met vis() worden gevisualiseerd. vis(kmers) Omdat dit onoverzichtelijk is gebruikt vis() de .head optie om te filteren. In het voorbeeld hieronder worden de 10 meest voorkomende Kmers eruit gefilterd om te visualiseren. De optie ‘.position’ kan worden gebruikt om de positie van de bars aan te passen. ook kan een ‘.log’ optie worden aangepast om de y-axis te transformeren met log. kvisual &lt;- vis(kmers, .head = 10) kvisual De functie kmer_profile kan daarna een sequentie motif analyse uitvoeren. Met de ‘.method’ optie kan worden aangegeven wat voor matrix eruit moet komen. “freq” is een ‘position frequency matrix’ die aangeeft hoe vaak een patroon zich op welke positie in de kmer bevindt. “prob” om een ‘position probability matrix’ te maken die aangeeft hoe groot de kans is dat een patroon zich op elke positie bevindt, deze optie maakt gebruik van de waardes uit de “freq” matrix. “wei” om een ‘position weight matrix’ wat hetzelfde aangeeft als de ‘position probability matrix’ maar dan na een log transformatie. profile &lt;- kmer_profile(kmers, &quot;freq&quot;) profile ## [,1] [,2] [,3] ## A 9283 9283 3791 ## C 6470 27 27 ## D 2131 2131 2131 ## E 5872 5872 5872 ## F 691 2601 9043 ## G 9603 9603 9603 ## H 405 684 684 ## I 1107 1107 1107 ## K 1100 1100 1100 ## L 4108 4108 4109 ## M 246 246 246 ## N 2424 2424 2424 ## P 2564 2564 2564 ## Q 7087 7087 7087 ## R 3506 3506 3504 ## S 14031 14031 13082 ## T 5671 6269 6269 ## V 1927 1927 1927 ## W 487 487 487 ## Y 2442 6098 6098 ## attr(,&quot;class&quot;) ## [1] &quot;immunr_kmer_profile_pfm&quot; &quot;matrix&quot; ## [3] &quot;array&quot; Deze tabel kan met vis() in een grafiek gezet worden. Hier wordt .plot gebruikt om aan te geven wat voor grafiek wordt gemaakt. “text” maakt een scatter plot terwijl de “seq” mogelijkheid het uitdrukt in letters met verbonden aan een kans. vis(profile, .plot = &quot;seq&quot;) Verder heb ik geprobeerd een dataset online te verkrijgen. Dit kreeg ik niet aan de praat. Hierom probeerde ik zelf een dataset te repliceren om te kijken of dat werkte. Dit deed ik door delen van de gegeven datasets te kopieren naar zelf gemaakte bestanden. Jammer genoeg werkte dit ook niet. Om toch te proberen dacht ik chatgpt data te laten genereren met de verwachting dat dit niet zou werken. Aangezien dit niet echt te doen is voor chatgpt komt er een kleine dataset. Toch is er iets te zien in 1 grafiek. De rest werkt niet. # Voorbeeld clonotype dataset (één sample) set.seed(123) # Voor reproduceerbaarheid # Functie om 1 sample te genereren generate_sample &lt;- function(n = 10) { data.frame( Clonotype = paste0(&quot;Clone&quot;, 1:n), CDR3.nt = paste0(&quot;ATG&quot;, sample(c(&quot;GCT&quot;, &quot;GGA&quot;, &quot;TTC&quot;, &quot;AAG&quot;, &quot;CCC&quot;, &quot;TTT&quot;), n, replace = TRUE), &quot;TAA&quot;), CDR3.aa = paste0(&quot;C&quot;, sample(c(&quot;ASS&quot;, &quot;ARR&quot;, &quot;SFS&quot;, &quot;CAG&quot;, &quot;YFG&quot;, &quot;GGG&quot;), n, replace = TRUE), &quot;F&quot;), V.name = sample(c(&quot;TRBV7-9&quot;, &quot;TRBV20-1&quot;, &quot;TRBV5-1&quot;, &quot;TRBV6-5&quot;), n, replace = TRUE), D.name = sample(c(&quot;TRBD1&quot;, &quot;TRBD2&quot;, NA), n, replace = TRUE), J.name = sample(c(&quot;TRBJ2-1&quot;, &quot;TRBJ1-2&quot;, &quot;TRBJ2-7&quot;, &quot;TRBJ1-1&quot;), n, replace = TRUE), Count = sample(10:150, n), Proportion = NA ) -&gt; df df$Proportion &lt;- df$Count / sum(df$Count) return(df) } # Genereer 4 samples sample1 &lt;- generate_sample() sample2 &lt;- generate_sample() sample3 &lt;- generate_sample() sample4 &lt;- generate_sample() # Combineer in een immunarch-compatibele lijst genomics &lt;- list() genomics$data &lt;- list( Gen1 = sample1, Gen2 = sample2, Gen3 = sample3, Gen4 = sample4 ) genomics ## $data ## $data$Gen1 ## Clonotype CDR3.nt CDR3.aa V.name D.name J.name Count Proportion ## 1 Clone1 ATGTTCTAA CGGGF TRBV7-9 TRBD2 TRBJ2-1 43 0.06213873 ## 2 Clone2 ATGTTTTAA CASSF TRBV7-9 TRBD1 TRBJ1-2 78 0.11271676 ## 3 Clone3 ATGTTCTAA CARRF TRBV5-1 &lt;NA&gt; TRBJ2-7 81 0.11705202 ## 4 Clone4 ATGGGATAA CSFSF TRBV6-5 &lt;NA&gt; TRBJ2-7 85 0.12283237 ## 5 Clone5 ATGGGATAA CYFGF TRBV20-1 TRBD1 TRBJ1-1 72 0.10404624 ## 6 Clone6 ATGTTTTAA CSFSF TRBV5-1 &lt;NA&gt; TRBJ2-1 106 0.15317919 ## 7 Clone7 ATGTTCTAA CSFSF TRBV20-1 TRBD2 TRBJ2-7 100 0.14450867 ## 8 Clone8 ATGCCCTAA CASSF TRBV7-9 TRBD1 TRBJ2-1 47 0.06791908 ## 9 Clone9 ATGAAGTAA CCAGF TRBV20-1 &lt;NA&gt; TRBJ2-7 30 0.04335260 ## 10 Clone10 ATGTTTTAA CASSF TRBV5-1 TRBD1 TRBJ1-1 50 0.07225434 ## ## $data$Gen2 ## Clonotype CDR3.nt CDR3.aa V.name D.name J.name Count Proportion ## 1 Clone1 ATGGGATAA CARRF TRBV20-1 &lt;NA&gt; TRBJ1-2 107 0.13161132 ## 2 Clone2 ATGAAGTAA CASSF TRBV7-9 TRBD1 TRBJ1-2 83 0.10209102 ## 3 Clone3 ATGAAGTAA CARRF TRBV6-5 TRBD2 TRBJ2-7 136 0.16728167 ## 4 Clone4 ATGTTTTAA CCAGF TRBV20-1 TRBD2 TRBJ2-1 26 0.03198032 ## 5 Clone5 ATGTTTTAA CYFGF TRBV7-9 &lt;NA&gt; TRBJ2-1 55 0.06765068 ## 6 Clone6 ATGTTCTAA CYFGF TRBV5-1 TRBD2 TRBJ1-1 63 0.07749077 ## 7 Clone7 ATGTTTTAA CGGGF TRBV5-1 TRBD1 TRBJ2-7 119 0.14637146 ## 8 Clone8 ATGTTTTAA CSFSF TRBV6-5 &lt;NA&gt; TRBJ1-2 103 0.12669127 ## 9 Clone9 ATGGCTTAA CASSF TRBV6-5 &lt;NA&gt; TRBJ1-2 88 0.10824108 ## 10 Clone10 ATGTTTTAA CCAGF TRBV20-1 &lt;NA&gt; TRBJ1-2 33 0.04059041 ## ## $data$Gen3 ## Clonotype CDR3.nt CDR3.aa V.name D.name J.name Count Proportion ## 1 Clone1 ATGGCTTAA CYFGF TRBV20-1 &lt;NA&gt; TRBJ2-1 118 0.15147625 ## 2 Clone2 ATGTTCTAA CSFSF TRBV7-9 TRBD1 TRBJ1-2 116 0.14890886 ## 3 Clone3 ATGCCCTAA CCAGF TRBV5-1 TRBD2 TRBJ2-7 86 0.11039795 ## 4 Clone4 ATGGGATAA CCAGF TRBV20-1 TRBD2 TRBJ1-1 45 0.05776637 ## 5 Clone5 ATGTTTTAA CGGGF TRBV6-5 TRBD1 TRBJ2-7 25 0.03209243 ## 6 Clone6 ATGTTTTAA CCAGF TRBV7-9 TRBD2 TRBJ2-1 134 0.17201540 ## 7 Clone7 ATGTTCTAA CYFGF TRBV5-1 &lt;NA&gt; TRBJ2-7 42 0.05391528 ## 8 Clone8 ATGGGATAA CSFSF TRBV6-5 &lt;NA&gt; TRBJ1-1 49 0.06290116 ## 9 Clone9 ATGCCCTAA CASSF TRBV6-5 TRBD1 TRBJ1-2 19 0.02439024 ## 10 Clone10 ATGTTTTAA CGGGF TRBV5-1 TRBD2 TRBJ2-1 145 0.18613607 ## ## $data$Gen4 ## Clonotype CDR3.nt CDR3.aa V.name D.name J.name Count Proportion ## 1 Clone1 ATGCCCTAA CASSF TRBV7-9 TRBD1 TRBJ1-2 50 0.05995204 ## 2 Clone2 ATGGCTTAA CYFGF TRBV6-5 TRBD1 TRBJ1-2 143 0.17146283 ## 3 Clone3 ATGGGATAA CYFGF TRBV20-1 TRBD1 TRBJ2-1 102 0.12230216 ## 4 Clone4 ATGCCCTAA CSFSF TRBV5-1 TRBD1 TRBJ1-2 66 0.07913669 ## 5 Clone5 ATGAAGTAA CARRF TRBV7-9 &lt;NA&gt; TRBJ2-1 75 0.08992806 ## 6 Clone6 ATGGGATAA CYFGF TRBV5-1 TRBD2 TRBJ2-1 13 0.01558753 ## 7 Clone7 ATGTTTTAA CGGGF TRBV20-1 TRBD2 TRBJ1-2 83 0.09952038 ## 8 Clone8 ATGGGATAA CYFGF TRBV6-5 TRBD2 TRBJ2-7 142 0.17026379 ## 9 Clone9 ATGTTCTAA CSFSF TRBV6-5 &lt;NA&gt; TRBJ2-1 126 0.15107914 ## 10 Clone10 ATGGCTTAA CSFSF TRBV7-9 TRBD1 TRBJ2-7 34 0.04076739 repOverlap(genomics$data) %&gt;% vis() #repExplore(genomics$data, .method = &quot;volume&quot;) "],["data-management.html", "4 Data management", " 4 Data management Deel a DAUR 2 formatieve opdracht dir_tree screenshot van de folder structuur Dit is de folder/file structuur gebruikt voor het rnaseq project van daur2. Na aanpassingen met gebruikt van de guerilla analytics structuur. Hieronder een screenshot van de inhoud van de README file readme file Deel b` Om de hele dir_tree in in het portfolio te zetten zijn meerdere screenshots gemaakt. deze 3 zijn onder elkaar gezet hier. Ook een screenshot van wat er in de README staat in het portfolio folder screenshot van de readme "],["reproducible.html", "5 Reproducible 5.1 Deel 1 5.2 Deel 2", " 5 Reproducible 5.1 Deel 1 library(readxl) df &lt;- read_xlsx(&quot;Reproducible/CE.LIQ.FLOW.062_Tidydata.xlsx&quot;) sapply(df[c(&quot;RawData&quot;, &quot;compName&quot;, &quot;compConcentration&quot;)], typeof) ## RawData compName compConcentration ## &quot;double&quot; &quot;character&quot; &quot;character&quot; compConcentration hoort geen character te zijn. concentraties zijn getallen. Om een grafiek te maken veranderen we de compConcentration eerst in een getal graph &lt;- df[, c(&quot;compName&quot;, &quot;compConcentration&quot;, &quot;RawData&quot;, &quot;expType&quot;)] #Eerst compConcentration veranderen naar numeric. graph$compConcentration &lt;- as.numeric(graph$compConcentration) ## Warning: NAs introduced by coercion #Een waarde wordt geteld als NA, dit kwam omdat een waarde met , was opgegeven. #Dit veranderen we met deze command gelijk voor de hele column graph$compConcentration &lt;- gsub(&quot;,&quot;, &quot;.&quot;, graph$compConcentration) #Nu kan de column verandert worden tot numeric graph$compConcentration &lt;- as.numeric(graph$compConcentration) graph ## # A tibble: 360 × 4 ## compName compConcentration RawData expType ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2,6-diisopropylnaphthalene 4.99 44 experiment ## 2 2,6-diisopropylnaphthalene 4.99 37 experiment ## 3 2,6-diisopropylnaphthalene 4.99 45 experiment ## 4 2,6-diisopropylnaphthalene 4.99 47 experiment ## 5 2,6-diisopropylnaphthalene 4.99 41 experiment ## 6 2,6-diisopropylnaphthalene 4.99 35 experiment ## 7 2,6-diisopropylnaphthalene 4.99 41 experiment ## 8 2,6-diisopropylnaphthalene 4.99 36 experiment ## 9 2,6-diisopropylnaphthalene 4.99 40 experiment ## 10 2,6-diisopropylnaphthalene 4.99 38 experiment ## # ℹ 350 more rows library(ggplot2) library(dplyr) graph %&gt;% ggplot(aes(x = compConcentration, y = RawData, color = compName, shape = expType)) + geom_jitter(width = 0.1, height = 0.1) + scale_x_log10() + theme_minimal() ## Warning in scale_x_log10(): log-10 transformation introduced infinite values. ## Warning: Removed 6 rows containing missing values or values outside the scale range ## (`geom_point()`). library(dplyr) library(ggplot2) #Stap 1: Bereken de gemiddelde waarde van de control_negative mean_control_negative &lt;- graph %&gt;% filter(expType == &quot;controlNegative&quot;) %&gt;% summarise(mean_value = mean(RawData, na.rm = TRUE)) %&gt;% pull(mean_value) #Stap 2: Normaliseer de data, zodat de negatieve controle gemiddeld 1 is graph_normalized &lt;- graph %&gt;% mutate(normalized_RawData = RawData / mean_control_negative) #Stap 3: Maak een scatter plot met de genormaliseerde waarden graph_normalized %&gt;% ggplot(aes(x = compConcentration, y = normalized_RawData, color = compName, shape = expType)) + geom_jitter(width = 0.1, height = 0.1) + scale_x_log10() + theme_minimal() + labs(y = &quot;Genormaliseerde waarde (t.o.v. controle)&quot;) ## Warning in scale_x_log10(): log-10 transformation introduced infinite values. ## Warning: Removed 6 rows containing missing values or values outside the scale range ## (`geom_point()`). Er zijn 3 controles gedaan tijdens het onderzoek. De negatieve controle is in dit geval een ‘normale’ situatie waarin de C. elegans kan leven. Deze test is gedaan om te kijken of de C. elegans wel bruikbaar zijn. Er zijn 2 positieve controles uitgevoerd. De verwachting voor de controlPositive was dat er door de ethanol die toegevoegd werd C.elegans doodgaan en het aantal nakomelingen dus daalt. De controlVehicleA is een controle om te onderzoeken of het wel de toegevoegde stof is die effect heeft, of dat het medium waarin de stof wordt opgelost ook invloed heeft. In dit geval kan dus bevestigt worden dat de controlVehicleA juist is. Als de te testen stof niet word toegevoegd zijn het aantal nakomelingen bijna hetzelfde als de controlNegative. De negatieve controle is gebruikt om de data te normaliseren. Dit is gedaan zodat het makkelijker is om de data te vergelijken met elkaar. Op deze manier kan de data vergeleken worden zonder dat er alleen naar vaste waarden wordt gekeken. Zo wordt gekeken naar de effecten van de stoffen ten opzichten van de normale situatie van C. elegans. Voor een vervolgonderzoek Zou kunnen worden gekeken naar de IC50 en LC50. Hieronder een stappenplan om de IC50 van een stof te visualiseren. Stap 1: Een stof die je wilt onderzoeken kiezen. De andere stoffen moeten eruit worden gefilterd voor de dose-response curve van een stof. Stap 2: De drc package heeft een functie om een log-logistisch model te maken. Dit is de drm functie. Stap 3: Gebruik de predict() functie van de drc package om een voorspelling te maken over de dosis range. Stap 4: Nu de voorspellingen in een R object staan kan een plot worden gemaakt. Dit kan gedaan worden met ggplot2 of een andere plot package naar wens. Hieronder een voorbeeld van een gecodeerd stappenplan. #Let op!!! #Hier staat een voorbeeld van het stappenplan. #Dit voorbeeld is gecodeerd door chatgpt!!! # Installeer en laad het pakket install.packages(&quot;drc&quot;) # alleen de eerste keer nodig ## package &#39;drc&#39; successfully unpacked and MD5 sums checked ## ## The downloaded binary packages are in ## C:\\Users\\justu\\AppData\\Local\\Temp\\RtmpIpRd8h\\downloaded_packages library(drc) library(ggplot2) library(dplyr) # Filter data voor één stof (bijvoorbeeld &#39;compoundA&#39;) data_filtered &lt;- graph_normalized %&gt;% filter(compName == &quot;naphthalene&quot;) # Pas een log-logistisch model toe model &lt;- drm(normalized_RawData ~ compConcentration, data = data_filtered, fct = LL.4()) # Toon samenvatting van het model (inclusief EC50) summary(model) ## ## Model fitted: Log-logistic (ED50 as parameter) (4 parms) ## ## Parameter estimates: ## ## Estimate Std. Error t-value p-value ## b:(Intercept) 3.529803 NaN NaN NaN ## c:(Intercept) 0.018190 0.043010 0.4229 0.6735 ## d:(Intercept) 0.876317 0.019721 44.4366 &lt;2e-16 *** ## e:(Intercept) 3.128989 NaN NaN NaN ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: ## ## 0.1513537 (80 degrees of freedom) # Genereer predicties voor de plot dose_range &lt;- data.frame(compConcentration = exp(seq(log(min(data_filtered$compConcentration, na.rm = TRUE)), log(max(data_filtered$compConcentration, na.rm = TRUE)), length.out = 100))) dose_range$predicted &lt;- predict(model, newdata = dose_range) # Maak de dose-response plot ggplot(data_filtered, aes(x = compConcentration, y = normalized_RawData)) + geom_point() + geom_line(data = dose_range, aes(x = compConcentration, y = predicted), color = &quot;blue&quot;) + scale_x_log10() + theme_minimal() + labs(title = &quot;Dose-response curve&quot;, x = &quot;Concentratie (log schaal)&quot;, y = &quot;Genormaliseerde respons&quot;) 5.2 Deel 2 Het gebruikte artikel wat gevonden is op PLOS One. Ik heb gebruikt als zoektermen; All fields: SARS-Cov-2 en data availibility: R code. (Zaaraoui et al., 2024) Onderdeel 1 De onderzoeksvraag: Welke soort antivirale behandeling is het meest effectief om verspreiding te voorkomen. De onderzoekers hebben een formule gemaakt voor de snelheid waarmee een geinfecteerde cel nieuwe virussen maakt. Deze formule zou rekening houden met het imuunsysteem. Een formule voor de verspreiding van het virus, deze formule houdt rekening met hoeveel nieuwe virussen zijn gemaakt, en hoe ‘erg’/dichtbij het contact is. Als laatst is een formule gemaakt die kijkt naar hoe effectief een behandeling is bij het remmen van productie van nieuwe virussen. De laatste formule heeft dus invloed op de andere twee. Data van het National Basketballs association’s cohort is gebruikt met data over SARS-CoV-2. Deze data is ingevoerd in de formules. Er zijn verschillende scenario’s met andere tijdstippen van behandeling. Onderdeel 2 Aangezien een groot deel van het gekozen artikel is gemaakt online, en de data komt uit een ander onderzoek worden de kopjes die te maken hebben met de data bekeken bij het originele onderzoek. Beoordeling van het artikel: Study Purpose: Yes Data Availibility Statement: Yes Data Location: Github repository link on PLOS. Study Location: No, Er wordt op een github verwezen naar de University of Washington, Department of Medicine en de Fred Hutchinson Cancer Center, Vaccine and Infectious Diseases Division, al staat er niet bij of hier het onderzoek is uitgevoerd om de raw data te verkrijgen. Author Review: No, alleen bij het originele onderzoek. Ethics Statement:No Funding Statement: Yes Code Availibility: No (Wel met omweg naar het originele onderzoek waar de data met R is bewerkt) Onderdeel 3 De R code die het artikel beweert te gebruiken kom vanuit een ander onderzoek waar de data is bewerkt met R. Deze R code is wel gevonden. Het artikel heeft niet benoemd dat het artikel waar de data van is er bij benoemd dat er een werkende versie van Stan en C++ toolchain geinstalleerd hoort te zijn. Toch lijkt het eerste script op github alleen R te gebruiken. Dus ga ik proberen de R code te runnen. Er staat in het onderzoek een R script waarmee de eerste 2 figuren zouden moeten worden gemaakt. Er wordt een onderzoek gedaan naar antistof hoeveelheden op moment van infectie en na een tijdje. Deze waardes worden vergeleken met mensen die gevaccineerd zijn, gevaccineerd worden tijdens het onderzoek of niet gevaccineerd zijn. Ook wordt er onderscheidt gemaakt tussen de soort vaccinatie. Eerst wordt de data gecleaned. Er wordt een soort infectie uit gefilterd. Ook worden een aantal kolommen aangepast omdat de data nog niet goed staat voor verdere analyses. Er worden negatieve variabele en NA’s uit gefilterd. Er is een functie gemaakt om snel de gemiddelde antistof-titer waardes te schatten door het gemiddelde vaak opnieuw te berekenen net anders. Er worden een plots gemaakt waarin te zien is hoe lang het duurt van infectie tot symptomen, of er een vertraging zit in het hoogste punt van de virale infectie vergeleken met wanneer de symptomen verschijnen. Een groot deel van de code bewerkt de data om een plot te maken waarmee de richting van de Ct waardes over de tijd worden aangewezen. Hier zijn ook weer verschillende plots gemaakt op basis van soort vaccinatie, leeftijdscategorie en antilichaam titer. Er zijn erg veel lines aan code geschreven om variabelen te kopelen. Hiermee kan een regressie model worden gemaakt om bijvoorbeeld p waardes te berekenen. Er kan gekeken worden naar of de soort vaccinatie invloed heeft op het verschijnen van symptomen of de curve/richting van de Ct waardes over de tijd. Na veel van de code zijn er een paar lines geschreven om de gemaakte plots of R objecten naar nieuwe files te kopiëren. Aan het einde zijn er een paar plots gemaakt die voorbeelden geven van de infectie curve bij een aantal van de patiënten. Ik beoordeel de leesbaarheid met een 3. De code is best goed te lezen maar er zouden meer comments in mogen zijn verwerkt om stappen uit te leggen. Ook zijn vooral aan het einde hele lange stukken geschreven om plots te maken. Dit zou voor mijn gevoel ook makkelijker kunnen of met een functie gedaan moeten worden aangezien er plots bij zitten die herhalend zijn met andere data. Ik heb zelf de data gedownload en het eerste script uitgeprobeerd. Dit heb ik gedaan door het script in een nieuwe Rmarkdown te zetten en met juiste verwijzingen te knitten. Ook waren de lines eruitgehaald waarmee de R objecten steeds opgeslagen werden in nieuwe files. Er waren wel een paar lines die te maken hadden met de soort patiënten. Deze lines hadden te maken met nonplayers. Dit was omdat de ‘players’ en ‘nonplayers’ anders gereguleert waren voor het testen, daarom dat deze werden gescheiden. Met de aangepaste paths naar mijn eigen gedownloade data bestand werkte het script meteen. Hierom geeft ik het artikel op reproduceerbaarheid een 5. (Houd er rekening mee dat het artikel wat ik hier gebruik de data gebruikt van een ander onderzoek, eigenlijk is dat andere onderzoek dus erg reproduceerbaar) "],["sql.html", "6 SQL", " 6 SQL Voor SQL hebben we een toets gemaakt om te kijken of je begrijpt hoe de SQL taal werkt. Hier werden vragen gesteld over het maken van databases. Ook werden vragen gesteld over het opzoeken van data in de databases om erachter te komen of je de commandos die te gebruiken zijn in SQL kent "],["package-maken.html", "7 Package maken", " 7 Package maken Voor deze opdracht heb ik een package gemaakt. Deze package moest 4 functions bevatten. Ik heb de package LSfunctions genoemd. De 4 functions heten: ‘gram_change’, ‘dilution’, ‘doorzetten’, en ‘potter’. De package zelf is beschreven in het engels, behalve de ‘doorzetten’ functie. De package is te installeren met: install.packages(“devtools”) library(“devtools”) devtools::install_github(“Justus789/LSfunctions”, build_vignettes = TRUE) library(“LSfunctions”) De build_vignettes optie staat op TRUE zodat je ook de browseVignettes(“LSfunctions”) functie kan uitvoeren. Deze functie kan meer informatie geven over de 4 functions die verwerkt zijn in LSfunctions. "],["project-referenties.html", "8 Project referenties", " 8 Project referenties korte uitleg In deze opdracht wordt een korte introductie geschreven over het project waar we tijdens deze cursus aan werken. Hiervoor wordt gewerkt met Zotero en de Zotero connector als chrome extensie om referenties te maken. Er worden 5 artikelen gezocht die informatie geven over single cell RNA sequencing en/of splicing. opdracht Single cell RNA sequencing is een manier van RNA sequencing waar gefocust wordt op individuele cellen. Bij deze manier van RNA sequencen krijg je van (meestal) grote aantallen cellen de RNA ‘activiteit’ van de genen. Op deze manier kan op basis van RNA activiteit celtypes en celstadia onderscheiden worden. Wij gebruiken bij ons project de Seurat package, deze kan gebruikt worden om cellen te clusteren. Cellen met soortgelijke RNA activiteit worden samengezet binnen een grafiek. In de grafiek is eenvoudig aan te geven welke clusters welk celtype of welk stadia van cel het zijn. Wel is kennis nodig van de celtypes die onderzocht zijn om deze clusters in te delen binnen een categorie.(Cheng et al., 2023) Om deze clusters te vormen word de data eerst genormaliseerd en zal PCA uitgevoerd worden. Dit wordt gedaan om de soms wel miljoenen cellen die allemaal variëren ‘samen te vatten’ tot principal components. Alle cellen die variëren worden verandert in groepen die gelijke variatie hebben. Zo worden de dimensies vermindert en simpelere clusters gemaakt worden. (Lähnemann et al., 2020) Nadat de clusters zijn gemaakt kan van elke cluster worden gekeken welke genen hoge activiteit hebben. Op basis hiervan worden celtypes toegewezen aan de clusters. Aangezien er nu clusters zijn met vergelijkbare variatie is het lastig om binnen een cluster verschillen aan te tonen. Splicing kan zorgen voor verschillen binnen een gen met meerdere exonen. Voor het onderzoeken van de verschillen die veroorzaakt worden door Splicing zijn ook packages/algoritmes gemaak. (Chen et al., 2019) Wij behandelen 3 packages tijdens dit project die worden gebruikt om single cell splicing te analyseren. De packages Brie2, Suppa2 en Whippet. Brie2 Brie2 is een R package wat gebruikt wordt om de verschillende isoformen te vinden binnen de clusters. Brie2 maakt gebruik van een Bayesian Hierarchical model. Dit model kan de splicing ratio voorspellen door te kijken naar eigenschappen van cel-soorten en cel-stadia. Brie2 heeft 4 soorten modi: bij de eerste (Mode0) wordt niet gekeken naar eigenschappen. Bij Mode1 wordt gekeken naar gen eigenschappen zoals gen sequenties. Mode2-quant heeft als doel om cellen te onderscheiden op basis van 1 eigenschap van de cellen. Deze eigenschap wordt bekeken en als er verschillen zijn geeft dit informatie over de Percentage of Spliced In (PSI). De laatste optie is Mode2-diff, met deze optie worden vergelijkingen gemaakt tussen cellen op basis van de cel eigenschappen. Voorbeelden zijn cel conditie. (Huang &amp; Sanguinetti, 2021) Suppa2 Suppa2 werkt op vergelijkbare manier. Het maakt gebruik van tools die snel het transcript kunnen quantificeren, ofwel berekenen hoeveel RNA wordt geuit. Suppa2 gebruikt de verschillen in uiting van RNA om de PSI te berekenen. Er wordt onderscheid gemaakt in de soorten van exon-skipping gebeurtenissen, F1 kan aangeven hoeveel transcript wordt geuit met een exon, terwijl F2 meer zegt over hoeveel transcript wordt geuit zonder het exon. (Alamancos et al., 2015) Whippet Whippet is ook een ‘event level’ tool om splicing te onderzoeken. Dit houdt in dat net als bij Suppa2 er wordt gekeken naar de splicing gebeurtenissen als exon-skipping. Whippet maakt daarnaast ook gebruik van entropie metingen. Whippet maakt ‘Continuous Splice Graphs’. Dit zijn grafieken waarin de punten exon regio’s aangeven en de verbindingen tussen punten geven aan hoe deze exon regio’s verbonden zijn. Dit kan door splicing events maar ook als een exonen naast elkaar liggen. Zo worden isoformen aangegeven door paden die zich onderscheiden tussen de exon regio’s. (Sterne-Weiler et al., 2018) "],["parameters-in-rmarkdown.html", "9 Parameters in Rmarkdown", " 9 Parameters in Rmarkdown Voor deze opdracht wordt in een rmarkdown bestand een analyse gecodeerd die gebruik maakt van parameters. De analyse wordt uitgevoerd op data verkregen tijdens covid, hieronder vallen variabelen als het land, het jaar, Cases en Deaths aan covid. Aangezien er gebruik moet worden gemaakt van parameters dacht ik dat het het makkelijkst is om te laten zien dat deze parameters werken in mijn Rmarkdown bestand door een filmpje te maken waarin je naast de code ook een voorbeeld ziet. Nadat de hele code is laten zien wordt een willekeurig land, jaar en maand gepakt om te laten zien dat de parameters werken zoals verwacht. De output is te zien in het filmpje. Your browser does not support the video tag. "],["references.html", "10 References", " 10 References Alamancos, G. P., Pagès, A., Trincado, J. L., Bellora, N., &amp; Eyras, E. (2015). Leveraging transcript quantification for fast computation of alternative splicing profiles. RNA, 21(9), 1521–1531. https://doi.org/10.1261/rna.051557.115 Chen, G., Ning, B., &amp; Shi, T. (2019). Single-Cell RNA-Seq Technologies and Related Computational Data Analysis. Frontiers in Genetics, 10, 317. https://doi.org/10.3389/fgene.2019.00317 Cheng, C., Chen, W., Jin, H., &amp; Chen, X. (2023). A Review of Single-Cell RNA-Seq Annotation, Integration, and Cell–Cell Communication. Cells, 12(15), 1970. https://doi.org/10.3390/cells12151970 Huang, Y., &amp; Sanguinetti, G. (2021). BRIE2: Computational identification of splicing phenotypes from single-cell transcriptomic experiments. Genome Biology, 22, 251. https://doi.org/10.1186/s13059-021-02461-5 Lähnemann, D., Köster, J., Szczurek, E., McCarthy, D. J., Hicks, S. C., Robinson, M. D., Vallejos, C. A., Campbell, K. R., Beerenwinkel, N., Mahfouz, A., Pinello, L., Skums, P., Stamatakis, A., Attolini, C. S.-O., Aparicio, S., Baaijens, J., Balvert, M., Barbanson, B. de, Cappuccio, A., … Schönhuth, A. (2020). Eleven grand challenges in single-cell data science. Genome Biology, 21, 31. https://doi.org/10.1186/s13059-020-1926-6 Sterne-Weiler, T., Weatheritt, R. J., Best, A. J., Ha, K. C. H., &amp; Blencowe, B. J. (2018). Efficient and Accurate Quantitative Profiling of Alternative Splicing Patterns of Any Complexity on a Laptop. Molecular Cell, 72(1), 187–200.e6. https://doi.org/10.1016/j.molcel.2018.08.018 Zaaraoui, H., Schumer, C., Duval, X., Hoen, B., Opatowski, L., &amp; Guedj, J. (2024). Modelling the effectiveness of antiviral treatment strategies to prevent household transmission of acute respiratory viruses. PLOS Computational Biology, 20(12), e1012573. https://doi.org/10.1371/journal.pcbi.1012573 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
